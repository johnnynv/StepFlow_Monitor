<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Execution - StepFlow Monitor</title>
    <link rel="stylesheet" href="/static/css/main.css">
    <link rel="stylesheet" href="/static/css/dashboard.css">
</head>
<body>
    <div class="app-container">
        <nav class="navbar">
            <div class="nav-brand">
                <h1>StepFlow</h1>
                <span class="nav-subtitle">Monitor</span>
            </div>
            <div class="nav-menu">
                <a href="/" class="nav-item">Dashboard</a>
                <a href="/history" class="nav-item">History</a>
            </div>
            <div class="nav-status">
                <span id="connectionStatus" class="connection-status">üü¢ Connected</span>
            </div>
        </nav>

        <main class="main-content">




            <!-- Live Execution Details -->
            <section class="execution-details" id="executionDetails" style="display: none;">
                <div class="execution-header">
                    <div class="execution-info">
                        <div class="info-item">
                            <label>Execution Name:</label>
                            <h4 id="executionName">-</h4>
                        </div>
                        <div class="info-item">
                            <label>Command:</label>
                            <p id="executionCommand">-</p>
                        </div>
                        <div class="execution-meta">
                            <div class="meta-item">
                                <label>Status:</label>
                                <span class="execution-status" id="executionStatus">-</span>
                            </div>
                            <div class="meta-item">
                                <label>Started:</label>
                                <span id="executionStartTime">-</span>
                            </div>
                            <div class="meta-item">
                                <label>Ended:</label>
                                <span id="executionEndTime">-</span>
                            </div>
                            <div class="meta-item">
                                <label>Duration:</label>
                                <span id="executionDuration">-</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Real-time Steps -->
                <div class="steps-container">
                    <h4>Execution Steps <span id="stepProgress">(0/0)</span></h4>
                    <div id="stepsProgress" class="steps-timeline">
                        <!-- Real-time steps will be populated here -->
                    </div>
                </div>
            </section>

            <!-- Execution Artifacts -->
            <section class="execution-artifacts" id="executionArtifacts" style="display: none;">
                <h4>Execution Artifacts</h4>
                <div class="artifacts-container">
                    <div class="artifacts-list" id="artifactsList">
                        <!-- Artifacts will be populated here -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script src="/static/js/websocket.js"></script>
    <script src="/static/js/api.js"></script>
    <script>
        class LiveExecutionMonitor {
            constructor() {
                this.selectedExecutionId = null;
                this.refreshInterval = 2000; // 2 seconds
                this.refreshTimer = null;
                this.expandedSteps = new Set(); // Track expanded steps
                
                this.init();
            }
            
            init() {
                this.startAutoRefresh();
                this.setupWebSocketListeners();
                
                // Check if there's an execution ID in URL
                const urlParams = new URLSearchParams(window.location.search);
                const executionId = urlParams.get('id');
                if (executionId) {
                    this.selectExecution(executionId);
                } else {
                    // Show message if no execution specified
                    document.getElementById('executionDetails').innerHTML = 
                        '<div class="info">Please select an execution from the Dashboard to monitor.</div>';
                    document.getElementById('executionDetails').style.display = 'block';
                }
            }
            

            
            async selectExecution(executionId) {
                this.selectedExecutionId = executionId;
                
                // Update URL
                const url = new URL(window.location);
                url.searchParams.set('id', executionId);
                window.history.replaceState({}, '', url);
                
                // Load execution details
                await this.loadExecutionDetails(executionId);
                
                // Load execution artifacts
                await this.loadExecutionArtifacts(executionId);
                
                // Show details section
                document.getElementById('executionDetails').style.display = 'block';
                document.getElementById('executionArtifacts').style.display = 'block';
            }
            
            async loadExecutionDetails(executionId) {
                try {
                    const response = await API.getExecution(executionId);
                    if (!response || !response.execution) return;
                    
                    const execution = response.execution; // API returns {execution: {...}, steps: [...], artifacts: [...]}
                    
                    // Update execution info
                    document.getElementById('executionName').textContent = execution.name || execution.id || '-';
                    document.getElementById('executionCommand').textContent = execution.command || '-';
                    document.getElementById('executionStatus').textContent = execution.status || '-';
                    document.getElementById('executionStatus').className = `execution-status status-${execution.status}`;
                    
                    // Update execution metadata with correct field names
                    const startTime = execution.started_at ? new Date(execution.started_at).toLocaleString() : '-';
                    const endTime = execution.completed_at ? new Date(execution.completed_at).toLocaleString() : '-';
                    const duration = this.calculateDuration(execution.started_at, execution.completed_at);
                    
                    document.getElementById('executionStartTime').textContent = startTime;
                    document.getElementById('executionEndTime').textContent = endTime;
                    document.getElementById('executionDuration').textContent = duration;
                    
                    // Load real-time steps
                    await this.loadExecutionSteps(executionId);
                    
                } catch (error) {
                    console.error('Failed to load execution details:', error);
                }
            }
            
            calculateDuration(startTime, endTime) {
                if (!startTime) return '-';
                
                const start = new Date(startTime);
                const end = endTime ? new Date(endTime) : new Date();
                const diff = end - start;
                
                const seconds = Math.floor(diff / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) {
                    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${seconds % 60}s`;
                } else {
                    return `${seconds}s`;
                }
            }
            
            async loadExecutionSteps(executionId) {
                try {
                    // For now, simulate step data - later this will come from the API
                    const steps = await this.getExecutionSteps(executionId);
                    
                    const stepsContainer = document.getElementById('stepsProgress');
                    const progressIndicator = document.getElementById('stepProgress');
                    
                    const completedSteps = steps.filter(step => step.status === 'completed').length;
                    progressIndicator.textContent = `(${completedSteps}/${steps.length})`;
                    
                    stepsContainer.innerHTML = steps.map((step, index) => {
                        const isExpanded = this.expandedSteps.has(index);
                        return `
                        <div class="step-item ${step.status}" id="step-${index}">
                            <div class="step-header" onclick="liveMonitor.toggleStepOutput(${index})">
                                <div class="step-icon">
                                    ${step.status === 'completed' ? '‚úÖ' : 
                                      step.status === 'running' ? 'üîÑ' : 
                                      step.status === 'failed' ? '‚ùå' : '‚è≥'}
                                </div>
                                <div class="step-info">
                                    <h5>${step.name}</h5>
                                    <span class="step-duration">${step.duration || ''}</span>
                                </div>
                                <div class="step-toggle ${isExpanded ? 'expanded' : ''}">
                                    ‚ñº
                                </div>
                            </div>
                            <div class="step-output ${isExpanded ? 'expanded' : 'collapsed'}" id="step-output-${index}">
                                <pre class="step-logs">${step.output || 'No output yet...'}</pre>
                            </div>
                        </div>
                        `;
                    }).join('');
                    
                } catch (error) {
                    console.error('Failed to load execution steps:', error);
                    document.getElementById('stepsProgress').innerHTML = 
                        '<div class="error">Failed to load steps</div>';
                }
            }
            
            async getExecutionSteps(executionId) {
                try {
                    // Get real execution data from API
                    const response = await API.getExecution(executionId);
                    if (!response || !response.steps) {
                        console.error('No steps data found for execution:', executionId);
                        return [];
                    }
                    
                    // Convert API step data to frontend format
                    return response.steps.map(step => {
                        // Calculate duration if available
                        let duration = '';
                        if (step.duration_seconds) {
                            if (step.duration_seconds < 60) {
                                duration = `${Math.round(step.duration_seconds)}s`;
                            } else if (step.duration_seconds < 3600) {
                                duration = `${Math.round(step.duration_seconds / 60)}m ${Math.round(step.duration_seconds % 60)}s`;
                            } else {
                                duration = `${Math.round(step.duration_seconds / 3600)}h ${Math.round((step.duration_seconds % 3600) / 60)}m`;
                            }
                        }
                        
                        // Format logs as output text
                        let output = '';
                        if (step.logs && step.logs.length > 0) {
                            output = step.logs.map(log => {
                                const timestamp = log.timestamp ? new Date(log.timestamp).toLocaleTimeString() : '';
                                return `[${timestamp}] ${log.content}`;
                            }).join('\n');
                        } else {
                            output = 'No logs available for this step';
                        }
                        
                        return {
                            name: step.name,
                            status: step.status,
                            duration: duration,
                            output: output,
                            index: step.index,
                            id: step.id
                        };
                    });
                } catch (error) {
                    console.error('Failed to load execution steps:', error);
                    // Fallback to empty array rather than hardcoded data
                    return [];
                }
            }
            
            async loadExecutionArtifacts(executionId) {
                try {
                    // Get execution details from API
                    const response = await API.getExecution(executionId);
                    if (!response) return;
                    
                    const artifacts = [];
                    
                    // Add real artifacts from API
                    if (response.artifacts && response.artifacts.length > 0) {
                        response.artifacts.forEach(artifact => {
                            artifacts.push({
                                name: artifact.name || artifact.file_name || 'Unknown Artifact',
                                type: artifact.artifact_type || 'file',
                                size: artifact.file_size ? this.formatBytes(artifact.file_size) : 'Unknown',
                                description: artifact.description || 'Execution artifact',
                                downloadable: true,
                                path: artifact.file_path || '',
                                id: artifact.id
                            });
                        });
                    }
                    
                    // Always include full output as an artifact with step names
                    const steps = await this.getExecutionSteps(executionId);
                    const fullOutput = steps.map(step => {
                        if (!step.output) return '';
                        return `=== STEP: ${step.name} ===\n${step.output}\n`;
                    }).filter(output => output).join('\n');
                    
                    if (fullOutput.trim()) {
                        artifacts.push({
                            name: 'Full Execution Output',
                            type: 'output',
                            size: this.formatBytes(fullOutput.length),
                            description: 'Complete output logs from all execution steps',
                            downloadable: true,
                            content: fullOutput
                        });
                    }
                    
                    this.renderArtifacts(artifacts);
                    
                } catch (error) {
                    console.error('Failed to load execution artifacts:', error);
                    document.getElementById('artifactsList').innerHTML = 
                        '<div class="error">Failed to load artifacts</div>';
                }
            }
            

            
            renderArtifacts(artifacts) {
                const container = document.getElementById('artifactsList');
                
                if (artifacts.length === 0) {
                    container.innerHTML = '<div class="info">No artifacts available</div>';
                    return;
                }
                
                container.innerHTML = artifacts.map((artifact, index) => `
                    <div class="artifact-item">
                        <div class="artifact-header">
                            <div class="artifact-icon">
                                ${artifact.type === 'output' ? 'üìÑ' : 'üìÅ'}
                            </div>
                            <div class="artifact-info">
                                <h5>${artifact.name}</h5>
                                <p class="artifact-description">${artifact.description}</p>
                                <span class="artifact-size">${artifact.size}</span>
                            </div>
                            <div class="artifact-actions">
                                ${artifact.downloadable ? 
                                    `<button onclick="liveMonitor.downloadArtifact(${index})" 
                                             class="btn btn-sm btn-primary">
                                        üì• Download
                                     </button>` : ''}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                // Store artifacts for download
                this.artifacts = artifacts;
            }
            
            downloadArtifact(index) {
                const artifact = this.artifacts[index];
                if (!artifact) return;
                
                if (artifact.type === 'output') {
                    // Download output as text file
                    const blob = new Blob([artifact.content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `execution-${this.selectedExecutionId}-output.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else if (artifact.path) {
                    // Download file from server
                    window.open(artifact.path, '_blank');
                }
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            toggleStepOutput(stepIndex) {
                const output = document.getElementById(`step-output-${stepIndex}`);
                const toggle = output?.parentElement.querySelector('.step-toggle');
                
                if (output) {
                    output.classList.toggle('collapsed');
                    output.classList.toggle('expanded');
                    
                    // Update expanded steps tracker
                    if (output.classList.contains('expanded')) {
                        this.expandedSteps.add(stepIndex);
                        if (toggle) toggle.classList.add('expanded');
                    } else {
                        this.expandedSteps.delete(stepIndex);
                        if (toggle) toggle.classList.remove('expanded');
                    }
                }
            }
            
            async loadExecutionLogs(executionId) {
                try {
                    const logs = await API.getExecutionLogs(executionId);
                    const logsContainer = document.getElementById('liveLogs');
                    
                    if (logs && logs.length > 0) {
                        logsContainer.innerHTML = logs.map(log => 
                            `<div class="log-entry">${log.timestamp}: ${log.message}</div>`
                        ).join('');
                    } else {
                        logsContainer.innerHTML = '<div class="info">No logs available</div>';
                    }
                    
                    // Auto-scroll to bottom
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                    
                } catch (error) {
                    console.error('Failed to load execution logs:', error);
                    document.getElementById('liveLogs').innerHTML = 
                        '<div class="error">Failed to load logs</div>';
                }
            }
            
            startAutoRefresh() {
                this.refreshTimer = setInterval(() => {
                    if (this.selectedExecutionId) {
                        this.loadExecutionDetails(this.selectedExecutionId);
                    }
                }, this.refreshInterval);
            }
            
            setupWebSocketListeners() {
                if (window.wsClient) {
                    wsClient.on('connected', () => {
                        document.getElementById('connectionStatus').innerHTML = 'üü¢ Connected';
                        document.getElementById('connectionStatus').className = 'connection-status connected';
                        this.loadActiveExecutions();
                    });
                    
                    wsClient.on('disconnected', () => {
                        document.getElementById('connectionStatus').innerHTML = 'üî¥ Disconnected';
                        document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    });
                    
                    wsClient.on('execution_update', (data) => {
                        if (data.execution_id === this.selectedExecutionId) {
                            this.loadExecutionDetails(this.selectedExecutionId);
                        }
                        this.loadActiveExecutions();
                    });
                }
            }
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.liveMonitor = new LiveExecutionMonitor();
        });
    </script>
</body>
</html>
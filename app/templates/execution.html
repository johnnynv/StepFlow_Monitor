<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Execution - StepFlow Monitor</title>
    <link rel="stylesheet" href="/static/css/main.css">
    <link rel="stylesheet" href="/static/css/dashboard.css">
</head>
<body>
    <div class="app-container">
        <nav class="navbar">
            <div class="nav-brand">
                <h1>StepFlow</h1>
                <span class="nav-subtitle">Monitor</span>
            </div>
            <div class="nav-menu">
                <a href="/" class="nav-item">Dashboard</a>
                <a href="/history" class="nav-item">History</a>
            </div>
            <div class="nav-status">
                <span id="connectionStatus" class="connection-status">üü¢ Connected</span>
            </div>
        </nav>

        <main class="main-content">




            <!-- Live Execution Details -->
            <section class="execution-details" id="executionDetails" style="display: none;">
                <div class="execution-header">
                    <div class="execution-info">
                        <div class="info-item">
                            <label>Execution Name:</label>
                            <h4 id="executionName">-</h4>
                        </div>
                        <div class="info-item">
                            <label>Command:</label>
                            <p id="executionCommand">-</p>
                        </div>
                        <div class="execution-meta">
                            <div class="meta-item">
                                <label>Status:</label>
                                <span class="execution-status" id="executionStatus">-</span>
                            </div>
                            <div class="meta-item">
                                <label>Started:</label>
                                <span id="executionStartTime">-</span>
                            </div>
                            <div class="meta-item">
                                <label>Ended:</label>
                                <span id="executionEndTime">-</span>
                            </div>
                            <div class="meta-item">
                                <label>Duration:</label>
                                <span id="executionDuration">-</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Real-time Steps -->
                <div class="steps-container">
                    <h4>Execution Steps <span id="stepProgress">(0/0)</span></h4>
                    <div id="stepsProgress" class="steps-timeline">
                        <!-- Real-time steps will be populated here -->
                    </div>
                </div>
            </section>

            <!-- Execution Artifacts -->
            <section class="execution-artifacts" id="executionArtifacts" style="display: none;">
                <h4>Execution Artifacts</h4>
                <div class="artifacts-container">
                    <div class="artifacts-list" id="artifactsList">
                        <!-- Artifacts will be populated here -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script src="/static/js/websocket.js"></script>
    <script src="/static/js/api.js"></script>
    <script>
        class LiveExecutionMonitor {
            constructor() {
                this.selectedExecutionId = null;
                this.refreshInterval = 2000; // 2 seconds
                this.refreshTimer = null;
                this.expandedSteps = new Set(); // Track expanded steps
                
                this.init();
            }
            
            init() {
                this.startAutoRefresh();
                this.setupWebSocketListeners();
                
                // Check if there's an execution ID in URL
                const urlParams = new URLSearchParams(window.location.search);
                const executionId = urlParams.get('id');
                if (executionId) {
                    this.selectExecution(executionId);
                } else {
                    // Show message if no execution specified
                    document.getElementById('executionDetails').innerHTML = 
                        '<div class="info">Please select an execution from the Dashboard to monitor.</div>';
                    document.getElementById('executionDetails').style.display = 'block';
                }
            }
            

            
            async selectExecution(executionId) {
                this.selectedExecutionId = executionId;
                
                // Update URL
                const url = new URL(window.location);
                url.searchParams.set('id', executionId);
                window.history.replaceState({}, '', url);
                
                // Load execution details
                await this.loadExecutionDetails(executionId);
                
                // Load execution artifacts
                await this.loadExecutionArtifacts(executionId);
                
                // Show details section
                document.getElementById('executionDetails').style.display = 'block';
                document.getElementById('executionArtifacts').style.display = 'block';
            }
            
            async loadExecutionDetails(executionId) {
                try {
                    const execution = await API.getExecution(executionId);
                    if (!execution) return;
                    
                    // Update execution info
                    document.getElementById('executionName').textContent = execution.name || execution.id;
                    document.getElementById('executionCommand').textContent = execution.command || '-';
                    document.getElementById('executionStatus').textContent = execution.status || '-';
                    document.getElementById('executionStatus').className = `execution-status status-${execution.status}`;
                    
                    // Update execution metadata
                    const startTime = execution.start_time ? new Date(execution.start_time).toLocaleString() : '-';
                    const endTime = execution.end_time ? new Date(execution.end_time).toLocaleString() : '-';
                    const duration = this.calculateDuration(execution.start_time, execution.end_time);
                    
                    document.getElementById('executionStartTime').textContent = startTime;
                    document.getElementById('executionEndTime').textContent = endTime;
                    document.getElementById('executionDuration').textContent = duration;
                    
                    // Load real-time steps
                    await this.loadExecutionSteps(executionId);
                    
                } catch (error) {
                    console.error('Failed to load execution details:', error);
                }
            }
            
            calculateDuration(startTime, endTime) {
                if (!startTime) return '-';
                
                const start = new Date(startTime);
                const end = endTime ? new Date(endTime) : new Date();
                const diff = end - start;
                
                const seconds = Math.floor(diff / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) {
                    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${seconds % 60}s`;
                } else {
                    return `${seconds}s`;
                }
            }
            
            async loadExecutionSteps(executionId) {
                try {
                    // For now, simulate step data - later this will come from the API
                    const steps = await this.getExecutionSteps(executionId);
                    
                    const stepsContainer = document.getElementById('stepsProgress');
                    const progressIndicator = document.getElementById('stepProgress');
                    
                    const completedSteps = steps.filter(step => step.status === 'completed').length;
                    progressIndicator.textContent = `(${completedSteps}/${steps.length})`;
                    
                    stepsContainer.innerHTML = steps.map((step, index) => {
                        const isExpanded = this.expandedSteps.has(index);
                        return `
                        <div class="step-item ${step.status}" id="step-${index}">
                            <div class="step-header" onclick="liveMonitor.toggleStepOutput(${index})">
                                <div class="step-icon">
                                    ${step.status === 'completed' ? '‚úÖ' : 
                                      step.status === 'running' ? 'üîÑ' : 
                                      step.status === 'failed' ? '‚ùå' : '‚è≥'}
                                </div>
                                <div class="step-info">
                                    <h5>${step.name}</h5>
                                    <span class="step-duration">${step.duration || ''}</span>
                                </div>
                                <div class="step-toggle ${isExpanded ? 'expanded' : ''}">
                                    ‚ñº
                                </div>
                            </div>
                            <div class="step-output ${isExpanded ? 'expanded' : 'collapsed'}" id="step-output-${index}">
                                <pre class="step-logs">${step.output || 'No output yet...'}</pre>
                            </div>
                        </div>
                        `;
                    }).join('');
                    
                } catch (error) {
                    console.error('Failed to load execution steps:', error);
                    document.getElementById('stepsProgress').innerHTML = 
                        '<div class="error">Failed to load steps</div>';
                }
            }
            
            async getExecutionSteps(executionId) {
                // Simulate step data - this would come from your marker parser
                return [
                    {
                        name: 'Environment Setup',
                        status: 'completed',
                        duration: '30s',
                        output: '[2025-08-01 22:30:15.123] Installing dependencies...\n[2025-08-01 22:30:18.456] Resolving package dependencies\n[2025-08-01 22:30:25.789] Setting up environment variables...\n[2025-08-01 22:30:30.012] Configuring runtime paths\n[2025-08-01 22:30:45.345] ‚úÖ Environment ready'
                    },
                    {
                        name: 'Data Processing',
                        status: 'failed',
                        duration: '15s',
                        output: '[2025-08-01 22:30:46.678] Loading data files...\n[2025-08-01 22:30:48.901] Reading configuration file\n[2025-08-01 22:30:50.234] Processing records...\n[2025-08-01 22:30:55.567] Validating data format\n[2025-08-01 22:31:01.890] ‚ùå Error: File not found - data.csv'
                    },
                    {
                        name: 'Model Training',
                        status: 'pending',
                        duration: '',
                        output: ''
                    }
                ];
            }
            
            async loadExecutionArtifacts(executionId) {
                try {
                    // Get execution details to collect output
                    const execution = await API.getExecution(executionId);
                    if (!execution) return;
                    
                    const artifacts = [];
                    
                    // Always include full output as an artifact with step names
                    const steps = await this.getExecutionSteps(executionId);
                    const fullOutput = steps.map(step => {
                        if (!step.output) return '';
                        return `=== STEP: ${step.name} ===\n${step.output}\n`;
                    }).filter(output => output).join('\n');
                    
                    artifacts.push({
                        name: 'Full Execution Output',
                        type: 'output',
                        size: this.formatBytes(fullOutput.length),
                        description: 'Complete output logs from all execution steps',
                        downloadable: true,
                        content: fullOutput
                    });
                    
                    // Check for additional artifacts (simulated for now)
                    const additionalArtifacts = await this.getAdditionalArtifacts(executionId);
                    artifacts.push(...additionalArtifacts);
                    
                    this.renderArtifacts(artifacts);
                    
                } catch (error) {
                    console.error('Failed to load execution artifacts:', error);
                    document.getElementById('artifactsList').innerHTML = 
                        '<div class="error">Failed to load artifacts</div>';
                }
            }
            
            async getAdditionalArtifacts(executionId) {
                // Simulate additional artifacts like pytest XML files
                // In real implementation, this would check the filesystem for declared artifacts
                return [
                    {
                        name: 'pytest-results.xml',
                        type: 'file',
                        size: '2.4 KB',
                        description: 'Pytest test results in XML format',
                        downloadable: true,
                        path: '/artifacts/pytest-results.xml'
                    },
                    {
                        name: 'coverage-report.html',
                        type: 'file',
                        size: '45.2 KB',
                        description: 'Code coverage report',
                        downloadable: true,
                        path: '/artifacts/coverage-report.html'
                    }
                ];
            }
            
            renderArtifacts(artifacts) {
                const container = document.getElementById('artifactsList');
                
                if (artifacts.length === 0) {
                    container.innerHTML = '<div class="info">No artifacts available</div>';
                    return;
                }
                
                container.innerHTML = artifacts.map((artifact, index) => `
                    <div class="artifact-item">
                        <div class="artifact-header">
                            <div class="artifact-icon">
                                ${artifact.type === 'output' ? 'üìÑ' : 'üìÅ'}
                            </div>
                            <div class="artifact-info">
                                <h5>${artifact.name}</h5>
                                <p class="artifact-description">${artifact.description}</p>
                                <span class="artifact-size">${artifact.size}</span>
                            </div>
                            <div class="artifact-actions">
                                ${artifact.downloadable ? 
                                    `<button onclick="liveMonitor.downloadArtifact(${index})" 
                                             class="btn btn-sm btn-primary">
                                        üì• Download
                                     </button>` : ''}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                // Store artifacts for download
                this.artifacts = artifacts;
            }
            
            downloadArtifact(index) {
                const artifact = this.artifacts[index];
                if (!artifact) return;
                
                if (artifact.type === 'output') {
                    // Download output as text file
                    const blob = new Blob([artifact.content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `execution-${this.selectedExecutionId}-output.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else if (artifact.path) {
                    // Download file from server
                    window.open(artifact.path, '_blank');
                }
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            toggleStepOutput(stepIndex) {
                const output = document.getElementById(`step-output-${stepIndex}`);
                const toggle = output?.parentElement.querySelector('.step-toggle');
                
                if (output) {
                    output.classList.toggle('collapsed');
                    output.classList.toggle('expanded');
                    
                    // Update expanded steps tracker
                    if (output.classList.contains('expanded')) {
                        this.expandedSteps.add(stepIndex);
                        if (toggle) toggle.classList.add('expanded');
                    } else {
                        this.expandedSteps.delete(stepIndex);
                        if (toggle) toggle.classList.remove('expanded');
                    }
                }
            }
            
            async loadExecutionLogs(executionId) {
                try {
                    const logs = await API.getExecutionLogs(executionId);
                    const logsContainer = document.getElementById('liveLogs');
                    
                    if (logs && logs.length > 0) {
                        logsContainer.innerHTML = logs.map(log => 
                            `<div class="log-entry">${log.timestamp}: ${log.message}</div>`
                        ).join('');
                    } else {
                        logsContainer.innerHTML = '<div class="info">No logs available</div>';
                    }
                    
                    // Auto-scroll to bottom
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                    
                } catch (error) {
                    console.error('Failed to load execution logs:', error);
                    document.getElementById('liveLogs').innerHTML = 
                        '<div class="error">Failed to load logs</div>';
                }
            }
            
            startAutoRefresh() {
                this.refreshTimer = setInterval(() => {
                    if (this.selectedExecutionId) {
                        this.loadExecutionDetails(this.selectedExecutionId);
                    }
                }, this.refreshInterval);
            }
            
            setupWebSocketListeners() {
                if (window.wsClient) {
                    wsClient.on('connected', () => {
                        document.getElementById('connectionStatus').innerHTML = 'üü¢ Connected';
                        document.getElementById('connectionStatus').className = 'connection-status connected';
                        this.loadActiveExecutions();
                    });
                    
                    wsClient.on('disconnected', () => {
                        document.getElementById('connectionStatus').innerHTML = 'üî¥ Disconnected';
                        document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    });
                    
                    wsClient.on('execution_update', (data) => {
                        if (data.execution_id === this.selectedExecutionId) {
                            this.loadExecutionDetails(this.selectedExecutionId);
                        }
                        this.loadActiveExecutions();
                    });
                }
            }
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.liveMonitor = new LiveExecutionMonitor();
        });
    </script>
</body>
</html>